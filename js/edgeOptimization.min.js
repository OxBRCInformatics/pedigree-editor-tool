/*! pedigree-editor-tool - v1.3.0-SNAPSHOT - 2017-05-19
* https://github.com/OxBRCInformatics/pedigree-editor-tool#readme
* Copyright (c) 2017  Licensed AGPL-3.0 */

VerticalPosIntOptimizer=function(pairScoreFunc,initLevels,minLevels){this.pairScoreFunc=pairScoreFunc,this.initLevels=initLevels,this.maxOfMinlevels=1,minLevels&&(this.maxOfMinlevels=Math.max.apply(null,minLevels),this.maxOfMinlevels>1&&(this.minLevels=minLevels));var precompute=this.computeComponents();this.components=precompute.components,this.crosses=precompute.crosses},VerticalPosIntOptimizer.prototype={numberOfLevelsPenalty:function(maxLevelUsed,minRequired,numEdges){return(maxLevelUsed-minRequired)/(numEdges+1)},componentScoreFunc:function(levels,componentID){for(var penalty=0,maxLevelUsed=0,minRequired=1,component=this.components.getComponentEdges(componentID),i=0;i<component.length;i++){var edge=component[i];levels[edge]>maxLevelUsed&&(maxLevelUsed=levels[edge]),this.minLevels&&this.minLevels[edge]>minRequired&&(minRequired=this.minLevels[edge]);for(var crosses=this.crosses[edge],j=0;j<crosses.length;j++){var intersects=crosses[j];if(intersects>edge&&(penalty+=this.pairScoreFunc(edge,intersects,levels[edge],levels[intersects],levels),!isFinite(penalty)))return penalty}}return penalty+=this.numberOfLevelsPenalty(maxLevelUsed,minRequired,component.length)},computeComponents:function(){for(var components=new Complonents,crosses=[],hasToBeAboveForPerfectScore=[],numEdges=this.initLevels.length,i=0;i<numEdges;i++)crosses[i]=[],hasToBeAboveForPerfectScore[i]=[];for(i=0;i<numEdges-1;i++)for(j=i+1;j<numEdges;j++)if(this.pairScoreFunc(i,j,1,1)==1/0){crosses[i].push(j),crosses[j].push(i);var componentI=components.getEdgeComponent(i),componentJ=components.getEdgeComponent(j);void 0===componentI&&void 0===componentJ?(components.addToNewComponent(i),components.addToExistingComponent(j,components.getEdgeComponent(i))):void 0!==componentI?void 0!==componentJ?componentI!=componentJ&&components.mergeComponents(componentI,componentJ):components.addToExistingComponent(j,componentI):components.addToExistingComponent(i,componentJ);var scoreAbove=this.pairScoreFunc(i,j,1,2),scoreBelow=this.pairScoreFunc(i,j,2,1),compID=components.getEdgeComponent(i);components.addRequiredPenaltyToComponent(compID,Math.min(scoreAbove,scoreBelow)),scoreAbove<scoreBelow&&hasToBeAboveForPerfectScore[i].push(j),scoreAbove>scoreBelow&&hasToBeAboveForPerfectScore[j].push(i)}for(compID=0;compID<components.getNumComponents();compID++){for(var minNumLevels=1,minRequired=1,minMinLevel=1/0,component=components.getComponentEdges(compID),i=0;i<component.length;i++){var edge=component[i];this.minLevels&&(this.minLevels[edge]>minRequired&&(minRequired=this.minLevels[edge]),this.minLevels[edge]<minMinLevel&&(minMinLevel=this.minLevels[edge]));for(var minForThisEdge=this.minLevels?this.minLevels[edge]:1,j=0;j<hasToBeAboveForPerfectScore[edge].length;j++){var needToBeAboveEdge=hasToBeAboveForPerfectScore[edge][j],minForOtherEdge=this.minLevels?this.minLevels[edge]:1;hasToBeAboveForPerfectScore[needToBeAboveEdge].length>0&&1==minForOtherEdge&&minForOtherEdge++,minForThisEdge=Math.max(minForThisEdge,minForOtherEdge+1)}minNumLevels=Math.max(minNumLevels,minForThisEdge)}var needExtraLevelsAboveMin=0==components.getMinPossiblePenalty(compID)?0:1;isFinite(minMinLevel)||(minMinLevel=1),minNumLevels=Math.max(minNumLevels,minMinLevel+needExtraLevelsAboveMin);var penaltyForNumLevelsUsed=this.numberOfLevelsPenalty(minNumLevels,minRequired,component.length);components.addRequiredPenaltyToComponent(compID,penaltyForNumLevelsUsed)}return{crosses:crosses,components:components}},computeVerticalPositions:function(maxFullSearchSize,maxSteps,seed){this.seed=seed||1;for(var bestSoFar=this.initLevels,compID=0;compID<this.components.getNumComponents();compID++)bestSoFar=this.components.getComponentEdges(compID).length<=maxFullSearchSize?this.exhaustiveSearch(compID,bestSoFar):this.simulatedAnnellingOptimizer(compID,bestSoFar,maxSteps);return bestSoFar},exhaustiveSearch:function(componentID,bestSoFar){var initScore=this.componentScoreFunc(bestSoFar,componentID);return this.recursiveExhaustiveSearch(componentID,bestSoFar.slice(0),0,{values:bestSoFar,score:initScore}).values},recursiveExhaustiveSearch:function(componentID,valuesSoFar,level,bestSoFar){var component=this.components.getComponentEdges(componentID);if(level==component.length){var score=this.componentScoreFunc(valuesSoFar,componentID);return score<bestSoFar.score&&(bestSoFar.values=valuesSoFar.slice(0),bestSoFar.score=score),bestSoFar}var edge=component[level],minValue=1,maxValue=component.length;this.minLevels&&(maxValue+=(minValue=this.minLevels[edge])-1);for(var i=minValue;i<=maxValue&&(valuesSoFar[edge]=i,(bestSoFar=this.recursiveExhaustiveSearch(componentID,valuesSoFar,level+1,bestSoFar)).score!=this.components.getMinPossiblePenalty(componentID));i++);return bestSoFar},makeBasicValidAssignment:function(initLevels,componentID){for(var component=this.components.getComponentEdges(componentID),value=1,newAssignemnt=initLevels.slice(0),i=0;i<component.length;i++){var edge=component[i];this.minLevels&&value<this.minLevels[edge]&&(value=this.minLevels[edge]),newAssignemnt[edge]=value,value++}return newAssignemnt},computeNeighbour:function(currentState,componentID,step){var component=this.components.getComponentEdges(componentID),newState=currentState.slice(0);do{for(var edge=component[Math.floor(this.random()*component.length)],oldLevel=newState[edge],maxUsedLevel=oldLevel,isBelowAll=!0,isAboveAll=!0,forbidden={},i=0;i<this.crosses[edge].length;i++){var crossLevel=newState[this.crosses[edge][i]];crossLevel>maxUsedLevel&&(maxUsedLevel=crossLevel),forbidden[crossLevel]=!0,crossLevel>=oldLevel&&(isAboveAll=!1),crossLevel<=oldLevel&&(isBelowAll=!1)}this.minLevels&&oldLevel==this.minLevels[edge]&&(isBelowAll=!0)}while(isAboveAll&&isBelowAll);var newLevel;do{newLevel=Math.floor(this.random()*(maxUsedLevel+2))}while(newLevel==oldLevel||isBelowAll&&newLevel<oldLevel||isAboveAll&&newLevel>oldLevel);if(forbidden.hasOwnProperty(newLevel))for(i=0;i<component.length;i++){var e=component[i];newState[e]<=newLevel&&newState[e]++}return newState[edge]=newLevel,this.normalize(newState,component),newState},normalize:function(levels,component){for(var usedLevels=Helpers.filterUnique(levels).sort(),i=usedLevels.length-1;i>0;i--)if(usedLevels[i]!=usedLevels[i-1]+1){for(j=0;j<component.length;j++){var e=component[j];levels[e]>=usedLevels[i]&&levels[e]--}break}for(i=0;i<component.length;i++)if((curLevel=levels[edge=component[i]])<(minLevel=this.minLevels?this.minLevels[edge]:1))for(var adjust=minLevel-curLevel,j=0;j<component.length;j++)levels[component[j]]+=adjust;do{for(var changed=!1,i=0;i<component.length;i++){var edge=component[i],curLevel=levels[edge],minLevel=this.minLevels?this.minLevels[edge]:1;if(curLevel>minLevel){for(var highestBelow=0,j=0;j<this.crosses[edge].length;j++){var level=levels[this.crosses[edge][j]];level<curLevel&&level>highestBelow&&(highestBelow=levels[this.crosses[edge][j]])}highestBelow<curLevel-1&&(levels[edge]=highestBelow+1)}}}while(changed)},localOptimization:function(levels,currentScore,componentID,untilFirstImprovement){return currentScore},random:function(){var x=16*Math.sin(this.seed++);return x-Math.floor(x)},doSwitchDuringAnneling:function(oldScore,newScore,stepsSinceReset){return newScore<=oldScore||Math.exp(-(newScore-oldScore)*Math.log(5*(stepsSinceReset+1)))>this.random()},simulatedAnnellingOptimizer:function(componentID,bestSoFar,maxSteps){for(var bestScore=this.componentScoreFunc(bestSoFar,componentID),bestState=isFinite(bestScore)?bestSoFar:this.makeBasicValidAssignment(bestSoFar,componentID),bestStep=maxSteps,currentState=bestState,currentScore=bestScore=isFinite(bestScore)?bestScore:this.componentScoreFunc(bestState,componentID),maxWrongDirection=maxSteps/6,step=maxSteps;bestScore>this.components.getMinPossiblePenalty(componentID)&&step>=0;){step<bestStep-maxWrongDirection&&(currentState=bestState.slice(0),currentScore=this.localOptimization(currentState,bestScore,componentID,!0),bestStep=step,console.log("[asearch] reset to: "+Helpers.stringifyObject(currentState)+", score: "+currentScore+" (@ step = "+(maxSteps-step+1)+")"));var neighbourState=this.computeNeighbour(currentState,componentID,step),neighbourScore=this.componentScoreFunc(neighbourState,componentID);this.doSwitchDuringAnneling(currentScore,neighbourScore,bestStep-step)&&(currentState=neighbourState,currentScore=neighbourScore),currentScore<bestScore&&(console.log("[asearch] New best: "+Helpers.stringifyObject(currentState)+", score: "+currentScore+" (@ step = "+(maxSteps-step+1)+")"),bestState=currentState.slice(0),bestScore=currentScore,bestStep=step),step--}return bestScore=this.localOptimization(bestState,bestScore,componentID),console.log("[asearch] Final optimized best: "+Helpers.stringifyObject(bestState)+", score: "+bestScore),bestState}},Complonents=function(){this.components=[],this.minPossiblePenalty=[],this.edgeComponents=[]},Complonents.prototype={getNumComponents:function(){return this.components.length},getComponentEdges:function(componentID){return this.components[componentID]},getEdgeComponent:function(edge){return this.edgeComponents[edge]},addToNewComponent:function(edge){this.edgeComponents[edge]=this.components.length,this.components.push([edge]),this.minPossiblePenalty.push(0)},addToExistingComponent:function(edge,componentID){this.components[componentID].push(edge),this.edgeComponents[edge]=componentID},mergeComponents:function(component1,component2){if(component1!=component2){for(var minID=Math.min(component1,component2),maxID=Math.max(component1,component2),i=0;i<this.components[maxID].length;i++){var edge=this.components[maxID][i];this.addToExistingComponent(edge,minID)}this.minPossiblePenalty[minID]+=this.minPossiblePenalty[maxID],this.components.splice(maxID,1),this.minPossiblePenalty.splice(maxID,1)}},addRequiredPenaltyToComponent:function(componentID,penalty){this.minPossiblePenalty[componentID]+=penalty},getMinPossiblePenalty:function(componentID){return this.minPossiblePenalty[componentID]}};