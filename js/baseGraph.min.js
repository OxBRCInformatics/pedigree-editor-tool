/*! pedigree-editor-tool - v1.3.1 - 2017-05-22
* https://github.com/OxBRCInformatics/pedigree-editor-tool#readme
* Copyright (c) 2017  Licensed AGPL-3.0 */

BaseGraph=function(defaultPersonNodeWidth,defaultNonPersonNodeWidth){this.v=[],this.inedges=[],this.maxRealVertexId=-1,this.weights=[],this.type=[],this.properties=[],this.vWidth=[],this.defaultPersonNodeWidth=defaultPersonNodeWidth||10,this.defaultNonPersonNodeWidth=defaultNonPersonNodeWidth||2},BaseGraph.TYPE={RELATIONSHIP:1,CHILDHUB:2,PERSON:3,VIRTUALEDGE:4},BaseGraph.prototype={serialize:function(saveWidth){for(var output=[],v=0;v<this.v.length;v++){var data={};data.id=v,saveWidth&&(data.width=this.vWidth[v]),this.type[v]==BaseGraph.TYPE.PERSON||(this.type[v]==BaseGraph.TYPE.RELATIONSHIP?(data.rel=!0,data.hub=!0):this.type[v]==BaseGraph.TYPE.CHILDHUB?data.chhub=!0:data.virt=!0),data.prop=this.properties[v],out=[];for(var outEdges=this.getOutEdges(v),i=0;i<outEdges.length;i++){var to=outEdges[i],weight=this.getEdgeWeight(v,to);1==weight?out.push({to:outEdges[i]}):out.push({to:outEdges[i],weight:weight})}out.length>0&&(data.outedges=out),output.push(data)}return output},makeGWithSplitMultiRankEdges:function(ranks){for(var newG=new BaseGraph(this.defaultPersonNodeWidth,this.defaultNonPersonNodeWidth),i=0;i<this.v.length;i++)newG._addVertex(i,this.type[i],this.properties[i],this.vWidth[i]);for(var sourceV=0;sourceV<this.v.length;sourceV++)for(var sourceRank=ranks[sourceV],i=0;i<this.v[sourceV].length;i++){var targetV=this.v[sourceV][i],weight=this.getEdgeWeight(sourceV,targetV),targetRank=ranks[targetV];if(targetRank<sourceRank)throw"Assertion failed: only forward edges";if(targetRank==sourceRank+1||targetRank==sourceRank)newG.addEdge(sourceV,targetV,weight);else{for(var prevV=sourceV,midRank=sourceRank+1;midRank<=targetRank-1;midRank++){var nextV=newG._addVertex(null,BaseGraph.TYPE.VIRTUALEDGE,{fName:"_"+sourceV+"->"+targetV+"_"+(midRank-sourceRank-1)},this.defaultNonPersonNodeWidth);ranks[nextV]=midRank,newG.addEdge(prevV,nextV,weight),prevV=nextV}newG.addEdge(prevV,targetV,weight)}}return newG.validate(),newG},makeGWithCollapsedMultiRankEdges:function(){for(var newG=new BaseGraph(this.defaultPersonNodeWidth,this.defaultNonPersonNodeWidth),i=0;i<=this.maxRealVertexId;i++)newG._addVertex(i,this.type[i],this.properties[i],this.vWidth[i]);for(var sourceV=0;sourceV<=this.maxRealVertexId;sourceV++)for(i=0;i<this.v[sourceV].length;i++){for(var targetV=this.v[sourceV][i],weight=this.getEdgeWeight(sourceV,targetV);targetV>this.maxRealVertexId;)targetV=this.getOutEdges(targetV)[0];newG.addEdge(sourceV,targetV,weight)}return newG.validate(),newG},getLeafAndParentlessNodes:function(){for(var result={parentlessNodes:[],leafNodes:[]},vid=0;vid<=this.maxRealVertexId;vid++)0==this.getInEdges(vid).length?result.parentlessNodes.push(vid):0==this.getOutEdges(vid).length&&result.leafNodes.push(vid);return result},_addVertex:function(id,type,properties,width){if(id&&this.v[id])throw"addVertex: vertex with id="+id+" is already in G";var nextId=null==id?this.v.length:id;return this.v[nextId]=[],this.inedges[nextId]=[],this.weights[nextId]={},this.vWidth[nextId]=width,this.type[nextId]=type,this.properties[nextId]=properties,type!=BaseGraph.TYPE.VIRTUALEDGE&&nextId>this.maxRealVertexId&&(this.maxRealVertexId=nextId),nextId},addEdge:function(fromV,toV,weight){if(this.v.length<Math.max(fromV,toV))throw"addEdge: vertex ID="+Math.max(fromV,toV)+"] is not in G";if(this.hasEdge(fromV,toV))throw"addEdge: edge from ID="+fromV+" to ID="+toV+" already exists";this.v[fromV].push(toV),this.inedges[toV].push(fromV),this.weights[fromV][toV]=weight},removeEdge:function(fromV,toV){if(!this.hasEdge(fromV,toV))throw"removeEdge: edge does not exist";Helpers.removeFirstOccurrenceByValue(this.v[fromV],toV),Helpers.removeFirstOccurrenceByValue(this.inedges[toV],fromV);var weight=this.weights[fromV][toV];return delete this.weights[fromV][toV],weight},insertVertex:function(type,properties,edgeWeights,inedges,outedges,width){var width=width||(type==BaseGraph.TYPE.PERSON?this.defaultPersonNodeWidth:this.defaultNonPersonNodeWidth);type!=BaseGraph.TYPE.PERSON||properties.hasOwnProperty("gender")||(properties.gender="U");var newNodeId=type==BaseGraph.TYPE.VIRTUALEDGE?this.v.length:this.maxRealVertexId+1;if(this.v.length>=newNodeId){var test=function(u){return u>=newNodeId},modification=function(u){return u+1};this._updateAllReferencesToNewIDs(test,modification)}this.v.splice(newNodeId,0,[]),this.inedges.splice(newNodeId,0,[]),this.weights.splice(newNodeId,0,{}),this.vWidth.splice(newNodeId,0,width),this.type.splice(newNodeId,0,type),this.properties.splice(newNodeId,0,properties),type!=BaseGraph.TYPE.VIRTUALEDGE&&this.maxRealVertexId++;for(i=0;i<inedges.length;i++)this.addEdge(inedges[i],newNodeId,edgeWeights);for(var i=0;i<outedges.length;i++)this.addEdge(newNodeId,outedges[i],edgeWeights);return newNodeId},unplugVirtualVertex:function(v){if(v<=this.getMaxRealVertexId())throw"Attempting to unplug a non-virtual vertex";var parent=this.inedges[v][0],child=this.v[v][0];Helpers.replaceInArray(this.v[parent],v,child),this.weights[parent][child]=this.weights[parent][v],delete this.weights[parent][v],Helpers.replaceInArray(this.inedges[child],v,parent),this.v[v]=[],this.inedges[v]=[],this.weights[v]={}},remove:function(v){for(i=0;i<this.v[v].length;i++){var target=this.v[v][i];Helpers.removeFirstOccurrenceByValue(this.inedges[target],v)}for(var i=0;i<this.inedges[v].length;i++){var incoming=this.inedges[v][i];Helpers.removeFirstOccurrenceByValue(this.v[incoming],v),delete this.weights[incoming][v]}this.v.splice(v,1),this.inedges.splice(v,1),this.weights.splice(v,1),this.vWidth.splice(v,1),this.type.splice(v,1),this.properties.splice(v,1),v<=this.maxRealVertexId&&this.maxRealVertexId--;var test=function(u){return u>v},modification=function(u){return u-1};this._updateAllReferencesToNewIDs(test,modification)},_updateAllReferencesToNewIDs:function(test,modification){for(var i=0;i<this.v.length;i++){for(j=0;j<this.v[i].length;j++)test(this.v[i][j])&&(this.v[i][j]=modification(this.v[i][j]));for(var j=0;j<this.inedges[i].length;j++)test(this.inedges[i][j])&&(this.inedges[i][j]=modification(this.inedges[i][j]));var newWeights={},weights=this.weights[i];for(var u in weights)weights.hasOwnProperty(u)&&(u=parseInt(u)),test(u)?newWeights[modification(u)]=weights[u]:newWeights[u]=weights[u];this.weights[i]=newWeights}},validate:function(){if(0!=this.v.length){for(v=0;v<this.v.length;v++){var outEdges=this.getOutEdges(v),inEdges=this.getInEdges(v);if(this.isPerson(v)){if(inEdges.length>1)throw"Assertion failed: person nodes can't have two in-edges as people are produced by a single pregnancy (failed for "+this.getVertexDescription(v)+")";for(i=0;i<outEdges.length;i++)if(!this.isRelationship(outEdges[i])&&!this.isVirtual(outEdges[i]))throw"Assertion failed: person nodes have only out edges to relationships (failed for "+this.getVertexDescription(v)+")"}else if(this.isRelationship(v)){if(0==outEdges.length)throw"Assertion failed: all relationships should have a childhub associated with them (failed for "+this.getVertexDescription(v)+")";if(outEdges.length>1)throw"Assertion failed: all relationships should have only one outedge (to a childhub) (failed for "+this.getVertexDescription(v)+")";if(!this.isChildhub(outEdges[0]))throw"Assertion failed: relationships should only have out edges to childhubs (failed for "+this.getVertexDescription(v)+")";if(2!=inEdges.length)throw"Assertion failed: relationships should always have exactly two associated persons (failed for "+this.getVertexDescription(v)+")"}else if(this.isVirtual(v)){if(1!=outEdges.length)throw"Assertion failed: all virtual nodes have exactly one out edge (to a virtual node or a relationship)";if(1!=inEdges.length)throw"Assertion failed: all virtual nodes have exactly one in edge (from a person or a virtual node)";if(!this.isRelationship(outEdges[0])&&!this.isVirtual(outEdges[0]))throw"Assertion failed: all virtual nodes may only have an outedge to a virtual node or a relationship"}else if(this.isChildhub(v)){if(outEdges.length<1)throw"Assertion failed: all childhubs should have at least one child associated with them";for(var i=0;i<outEdges.length;i++)if(!this.isPerson(outEdges[i]))throw"Assertion failed: childhubs are only connected to people (failed for "+this.getVertexDescription(v)+")"}}var leafAndRootlessInfo=this.getLeafAndParentlessNodes();if(0==leafAndRootlessInfo.parentlessNodes.length)throw"Assertion failed: pedigrees should have no cycles (no parentless nodes found)";for(var j=0;j<leafAndRootlessInfo.parentlessNodes.length;j++)if(this._DFSFindCycles(leafAndRootlessInfo.parentlessNodes[j],{}))throw"Assertion failed: pedigrees should have no cycles";var reachable={};this._markAllReachableComponents(leafAndRootlessInfo.parentlessNodes[0],reachable);for(var v=0;v<this.v.length;v++)if(!reachable.hasOwnProperty(v))throw"Assertion failed: disconnected component detected ("+this.getVertexDescription(v)+")"}},_DFSFindCycles:function(vertex,visited){visited[vertex]=!0;for(var outEdges=this.getOutEdges(vertex),i=0;i<outEdges.length;i++){var v=outEdges[i];if(visited.hasOwnProperty(v))return!0;if(this._DFSFindCycles(v,visited))return!0}return delete visited[vertex],!1},_markAllReachableComponents:function(vertex,reachable){reachable[vertex]=!0;for(var outEdges=this.getOutEdges(vertex),i=0;i<outEdges.length;i++){v=outEdges[i];reachable.hasOwnProperty(v)||this._markAllReachableComponents(v,reachable)}for(var inEdges=this.getInEdges(vertex),j=0;j<inEdges.length;j++){var v=inEdges[j];reachable.hasOwnProperty(v)||this._markAllReachableComponents(v,reachable)}},getVertexNameById:function(v){var firstname=this.properties[v].hasOwnProperty("fName")?this.properties[v].fName:"",lastname=this.properties[v].hasOwnProperty("lName")?this.properties[v].lName:"";return""!=firstname&&""!=lastname&&(firstname+=" "),firstname+lastname},getVertexDescription:function(v){var desc="id: "+v+", name: <"+this.getVertexNameById(v)+">, type: ";switch(this.type[v]){case BaseGraph.TYPE.PERSON:desc+="PERSON";break;case BaseGraph.TYPE.RELATIONSHIP:desc+="RELATION";break;case BaseGraph.TYPE.CHILDHUB:desc+="CHILDHUB";break;case BaseGraph.TYPE.VIRTUALEDGE:desc+="VIRTUAL";break;default:desc+="ERROR"}return"["+desc+"]"},getVertexWidth:function(v){return this.vWidth[v]},getVertexHalfWidth:function(v){return Math.floor(this.vWidth[v]/2)},getEdgeWeight:function(fromV,toV){return this.weights[fromV][toV]},hasEdge:function(fromV,toV){return this.weights[fromV].hasOwnProperty(toV)},isValidId:function(v){return v>=0&&v<this.v.length},getNumVertices:function(){return this.v.length},getMaxRealVertexId:function(){return this.maxRealVertexId},getOutEdges:function(v){return this.v[v]},getInEdges:function(v){return this.inedges[v]},getAllEdgesWithWeights:function(v){for(var edgeToWeight={},outEdges=this.getOutEdges(v),i=0;i<outEdges.length;i++)edgeToWeight[u=outEdges[i]]={weight:this.weights[v][u],out:!0};for(var inEdges=this.getInEdges(v),i=0;i<inEdges.length;i++){var u=inEdges[i];edgeToWeight[u]={weight:this.weights[u][v],out:!1}}return edgeToWeight},getAllEdges:function(v){return this.getOutEdges(v).concat(this.getInEdges(v))},isRelationship:function(v){return this.type[v]==BaseGraph.TYPE.RELATIONSHIP},isChildhub:function(v){return this.type[v]==BaseGraph.TYPE.CHILDHUB},isPerson:function(v){return this.type[v]==BaseGraph.TYPE.PERSON},isPlaceholder:function(v){return!(!this.isPerson(v)||!this.properties[v].hasOwnProperty("placeholder"))&&!!this.properties[v].placeholder},isVirtual:function(v){return this.type[v]==BaseGraph.TYPE.VIRTUALEDGE},isAdoptedIn:function(v){return!!this.properties[v].hasOwnProperty("adoptedStatus")&&"adoptedIn"==this.properties[v].adoptedStatus},isAdoptedOut:function(v){return!!this.properties[v].hasOwnProperty("adoptedStatus")&&"adoptedOut"==this.properties[v].adoptedStatus},getGender:function(v){if(!this.isPerson(v))throw"Assertion failed: attempting to get gender of a non-person";return this.properties[v].gender},getLastName:function(v){if(!this.isPerson(v))throw"Assertion failed: attempting to get last name of a non-person";return this.properties[v].hasOwnProperty("lName")?this.properties[v].lName:this.properties[v].hasOwnProperty("lNameAtB")?this.properties[v].lNameAtB:""},getLastNameAtBirth:function(v){if(!this.isPerson(v))throw"Assertion failed: attempting to get last name at birth of a non-person";return this.properties[v].hasOwnProperty("lNameAtB")?this.properties[v].lNameAtB:""},getOppositeGender:function(v){if(!this.isPerson(v))throw"Assertion failed: attempting to get gender of a non-person";return"U"==this.getGender(v)?"U":"O"==this.getGender(v)?"U":"M"==this.getGender(v)?"F":"M"},getRelationshipChildhub:function(v){if(!this.isRelationship(v))throw"Assertion failed: applying getRelationshipChildhub() to a non-relationship node";return this.v[v][0]},getAllRelationships:function(v){if(!this.isPerson(v))throw"Assertion failed: attempting to get relationships of a non-person";for(var relationships=this.v[v],result=[],r=0;r<relationships.length;++r){var edgeTo=relationships[r],relationship=this.downTheChainUntilNonVirtual(edgeTo);result.push(relationship)}return result},getAllPartners:function(v){if(!this.isPerson(v))throw"Assertion failed: attempting to get partners of a non-person";for(var relationships=this.getAllRelationships(v),result=[],r=0;r<relationships.length;++r){var partners=this.getParents(relationships[r]);partners[0]!=v?result.push(partners[0]):result.push(partners[1])}return result},getParents:function(v){if(!this.isPerson(v)&&!this.isRelationship(v))throw"Assertion failed: attempting to get parents of a non-person and non-relationship";var parentRelationship=this.isPerson(v)?this.getProducingRelationship(v):v;if(null==parentRelationship)return[];var inEdges=this.getInEdges(parentRelationship);if(2!=inEdges.length)throw"Assertion failed: exactly two parents";return[this.upTheChainUntilNonVirtual(inEdges[0]),this.upTheChainUntilNonVirtual(inEdges[1])]},getPathToParents:function(v){var result=[];if(!this.isRelationship(v))throw"Assertion failed: incorrect v in getPathToParents()";var inEdges=this.getInEdges(v);return result.push(this.getUpPathEndingInNonVirtual(inEdges[0])),result.push(this.getUpPathEndingInNonVirtual(inEdges[1])),result},getProducingRelationship:function(v){if(!this.isPerson(v))throw"Assertion failed: attempting to get producing relationship of a non-person";if(0==this.inedges[v].length)return null;var chHub=this.inedges[v][0];return 0==this.inedges[chHub].length?null:this.inedges[chHub][0]},upTheChainUntilNonVirtual:function(v){return this.isVirtual(v)?this.upTheChainUntilNonVirtual(this.inedges[v][0]):v},downTheChainUntilNonVirtual:function(v){return this.isVirtual(v)?this.downTheChainUntilNonVirtual(this.v[v][0]):v},getUpPathEndingInNonVirtual:function(v){for(var path=[v];this.isVirtual(v);)v=this.inedges[v][0],path.push(v);return path},getUnusedTwinGroupId:function(v){if(!this.isRelationship(v))throw"Assertion failed: incorrect v in getNumTwinGroups()";for(var childhubId=this.v[v][0],children=this.v[childhubId],twinGroupExists=[],c=0;c<children.length;c++){var child=children[c];this.properties[child].hasOwnProperty("twinGroup")&&(twinGroupExists[this.properties[child].twinGroup]=!0)}for(var firstFreeTwinGroupId=0,i=0;i<twinGroupExists.length&&void 0!==twinGroupExists[i];i++)firstFreeTwinGroupId=i+1;return firstFreeTwinGroupId},getTwinGroupId:function(v){return this.properties[v].hasOwnProperty("twinGroup")?this.properties[v].twinGroup:null},getAllSiblingsOf:function(v){if(!this.isPerson(v))throw"Assertion failed: incorrect v in getAllSiblingsOf()";if(0==this.inedges[v].length)return[v];var childhubId=this.inedges[v][0];return this.v[childhubId].slice(0)},getAllTwinsOf:function(v){if(!this.isPerson(v))throw"Assertion failed: incorrect v in getAllTwinsOf()";if(!this.properties[v].hasOwnProperty("twinGroup")||0==this.inedges[v].length)return[v];for(var twinGroupId=this.properties[v].twinGroup,childhubId=this.inedges[v][0],children=this.v[childhubId],twins=[],c=0;c<children.length;c++){var child=children[c];this.properties[child].hasOwnProperty("twinGroup")&&this.properties[child].twinGroup==twinGroupId&&twins.push(child)}return twins},isParentToTwinEdge:function(fromV,toV){return!(!this.isPerson(toV)||!this.isChildhub(fromV)||null==this.getTwinGroupId(toV))},getAllAncestors:function(v){var ancestors={};ancestors[v]=!0;var q=new Queue;for(q.push(v);q.size()>0;)for(var nextV=q.pop(),inEdges=this.getInEdges(nextV),j=0;j<inEdges.length;j++){var v=inEdges[j];ancestors.hasOwnProperty(v)||(q.push(v),ancestors[v]=!0)}return ancestors}};